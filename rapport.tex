\documentclass{article}
\usepackage{minted}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{mathtools}
\usepackage{graphicx} 
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}
\urlstyle{same}

\title{Rapport projet PFA 2018-2019}
\date{\today}
\author{Lam NGUYEN THIET
\and Kenyu KOBAYASHI}
\begin{document}
\maketitle
\tableofcontents
\newpage
\section{Introduction}
Ce projet implémente un jeu dans le langage OCAML, en utilisant les fonctionalités fonctionelles (en majorité), impératives, orientée objet.

\section{Le jeu}
\subsection{But}
Le but du jeu est de détruire les factions ennemies. Pour se faire, il suffit de tuer toutes leur unités.

\subsection{Factions}
Il y a 3 factions dans le jeu. Les cagoulés, les vert et les bleus. Vous contrôlez les bleus.

\subsection{Unités}
Il existe deux types d'unités.

\begin{itemize}
    \item Le soldat est l'unité de base. Elle peut se déplacer, attaquer et récupérer des items.
    \item La ville permet de faire apparaître des soldats. Cette unité est très importante car si on la perd, on ne peut plus produire de soldat.
\end{itemize}

\subsection{Items}
Il existe deux items.

\begin{itemize}
    \item Le pack de soin régénére la vie des unités. Il est possible d'avoir plus de points de vie que l'on avait au départ.
    \item La bombe nucléaire détruit tout dans un rayon de 3 cases.
\end{itemize}

\subsection{Plateau du jeu}
Le plateau est une grille d'hexagone. La carte est une île deserte dans l'océan avec des biômes variés.

\subsubsection{Type de cases}
Il y a 3 types de cases. A l'heure actuelle, elle ne sont que cosmétiques, par la suite elle peuvent avoir un impact sur l'efficacité de combat de tel unité de
tel faction, mais par manque de temps je n'ai pas pu les faire.

Il y a la neige, le desert et l'herbe.

\subsubsection{Caractèristiques du terrain}
En plus du biome, il y a des caractèristiques sur le terrain pour chaque case.

\begin{itemize}
    \item Les forêts et les collines coûtent plus cher pour le movement.
    \item Les montagnes et les lacs sont des obstacles ne peuvent pas être traversés.
\end{itemize}

\subsection{Tour par tour}
Le jeu se déroule en tour par tour, similaire au jeu \textit{Civilization}. C'est d'ailleurs
sur quoi je me suis inspiré pour le jeu.

\subsubsection{Mouvement}

Chaque unité a un nombre de movement. Lorsqu'il se déplace d'une case, il consomme $n$ points selon la case sur laquelle il atterit.
Dans le jeu, les soldats sont les seuls à pouvoir se déplacer. Les villes ne peuvent pas.

\subsubsection{Attaque}
Pour tuer les autres unités il faut les attaquer. Encore une fois de manière analogue à \textit{Civilization},
les unités disposent d'une force d'attaque et d'une force de défense.

Par la suite, $src$ et $dst$ représente respectivement l'unité qui attaque et l'unité
qui défend.

Lorsque deux unités s'attaquent, les nouveaux point de vie se calculent de cette manière : 

\begin{align}
    healthpoints_{dst,new} &= max \{0,healthpoints_{dst,old} - strength_{attack,src}\} \\
    healthpoints_{src,new} &= max \{0,healthpoints_{src,old} - strength_{defense,dst}\}
\end{align}

Et leurs nouvelles positions : 
\begin{align}
     x_{dst,new},y_{dst,new} &=
     \begin{cases}
        \texttt{null},\texttt{null} & \text{si } healthpoints_{dst_,new} = 0 \text{,}\\
        x_{dst,old},y_{dst,old} & \text{sinon.} 
     \end{cases} \\
     x_{src,new},y_{src,new} &=
     \begin{cases}
        \texttt{null},\texttt{null} & \text{si } healthpoints_{src,new} = 0 \text{,}\\
        x_{dst,old},y_{dst,old} & \text{si } healthpoints_{dst_,new} = 0 \text{,}\\
        x_{src,old},y_{src,old} & \text{sinon.} 
     \end{cases}
\end{align}

\subsection{Intelligence Artificielle}
Les IA sont assez simple. De base, elles se déplacent au hasard.
Si elles rencontrent un ennemi, elle va se diriger vers cet ennemi en priorité. Si il y a un
autre ennemi elles s'attaquent, même si ce n'était pas l'ennemi en priorité.

En dessous d'un certain seuil, les IA vont chercher à fuire et chercher un pack de soin. Mais si il y a un ennemi
tout prés, elles vont se suicider et attaquer cet ennemi, car elles savent qu'elles vont mourir et vont préférer attaquer 
pour donner une chance à leur alliés.

Sinon, en mode patrouille, si elles voient une bombe nucléaire, elles la prennent et l'utilise sur un ennemi au hasard.
\section{Répartition du travail}
\subsection{NGUYEN THIET}
\begin{itemize}
    \item Gestion des appels à la bibliothéque SDL ( \textit{e.g.,} gestion du render, chargement des textures, initialisation
    du windows, \textit{etc.} )
    \item Dessins (tuiles, caractèristiques de terrain, soldats, ville, interfaces, fond d'écran, titre, items, effets spéciaux)
    \item Boucle principale. Gestion d'un type \texttt{context}, comment le mettre à jour et comment récupérer informations contenus pour avancer le jeu dans le temps
    \item Définition du type des \texttt{unités} et les méthodes associées
    \item Implémentation du plateau de jeu et la grille d'héxagone. (Les pseudocodes se trouvent ici \url{https://www.redblobgames.com/grids/hexagons/})
    \item Gestion et
\end{itemize}

\subsection{KOBAYASHI}
\begin{itemize}
    \item Calcul des PV et mise à jour du plateau pendant les attaques 
    \item Réglages de la taille de la carte dans le menu
    \item Fond d'écran des réglages (juste le dégradé)
\end{itemize}

\end{document}


\section{Développement du jeu}
Chaque phase sera développée plus en profondeur dans la suite du rapport.
Chaque implémentation est listé par ordre chronologique dans le développement.

\subsection*{Phase 1 : Fondation}
\begin{enumerate}
    \item Familiarisation avec \texttt{SDL} et factorisation de code qui était assez récurrent.
    \item Implémentation de la boucle principale
    \item Généralisation du type \texttt{context} et sa mise à jour
\end{enumerate}

\subsection*{Phase 2 : Instances de jeu}
\begin{enumerate}
    \item Définition des instances du jeu (la boucle du menu, du jeu etc. )
    \item Création de boutons temporaires pour lancer le jeu et le quitter si on appuie sur la croix
\end{enumerate}


\subsection*{Phase 3 : Plateau de jeu}
\begin{enumerate}
    \item Définition du plateau de jeu (représenté par une matrice)
    \item Implémentation des fonctionalités de la grille d'hexagone
    \item Définition des tuiles et des \texttt{enum} qui la définissent
    \item Les dessins du plateau (tuiles, forêts, etc.)
\end{enumerate}

\subsection*{Phase 4 : Unités}
\begin{enumerate}
    \item Définition des unités
    \item Définition des constantes qui les définissent
    \item Les dessins des unités
\end{enumerate}

\subsection*{Phase 5 : Actions}
\begin{enumerate}
    \item Formalisation et généralisation des actions et leur retour pour qu'ils puissent tous être du même type
    \item Implémentation des actions de déplacement et attaques
    \item Interaction temporaire avec les unités avec le clavier
    \item Interaction du retour des actions avec le système de contexte
\end{enumerate}


\subsection*{Phase 6 : Animation}
\begin{enumerate}
    \item Définition d'un type stockant les informations nécessaire aux animations
    \item Système de rendu pour les animations couplé avec les effets spéciaux
\end{enumerate}

\subsection*{Phase 7 : IA}
\begin{enumerate}
    \item Formalisation d'un comportement d'une unité 
    \item Systèmes similaire aux automates d'états finis pour sélectionner le comportement de chaque unités selon son environment
    \item IA qui se déplacement au hasard,
    \item et attaque une cible si il y en a une qui se trouve à proximité,
    \item et qui va chercher des packs de soin si elles n'a pas beaucoup de points de vie,
    \item et qui va chercher les bombes nucléaires si elle peut.
\end{enumerate}

\subsection*{Phase 8 : Interfaces}
\begin{enumerate}
    \item Affichage des informations liés à chaque unités (ses points de vie et points de mouvement)
    \item Système d'interface avec des \textit{event listeners}
    \item Formalisation et généralisation des interactions avec les interfaces dans le contexte
\end{enumerate}

\section{Quelques explications}
\subsection{Contexte \& Boucle principale}
Vous remarquerez que le fichier \texttt{context.ml} contient une (très) grande partie du code. Son rôle
est de définir le type \texttt{context} et de mettre à jour la variable qui y est associé.
Dans ce type on trouve tout ce dont nous avons besoin pour faire tourner le jeu : 

\begin{minted}{ocaml}
type t = {
    over : bool; 
    camera : MCamera.t;
    grid : MGrid.t;
    cursor_selector : MCursor.cursor;
    faction_list : MFaction.t list;
    faction_controlled_by_player : MFaction.t;
    action_src : MHex.axial_coord option;
    action_dst : MHex.axial_coord option;
    action_layer : MLayer_enum.t option;
    action_type : MAction_enum.enum option;
    movement_range_selector : MTile.t list;
    to_be_added : MEntity.t list;
    to_be_deleted : MEntity.t list;
    animation : MAnimation.t;
    new_turn : bool;
    frame : int;
    scale : float;
    interface : MInterface.structure;
    current_layer : MLayer_enum.t;
    window : Sdl.window;
}
\end{minted}

Et pour chacun de ces attributs, il existe une fonction qui fait un appel aux autres modules, prend la réponse
et modifie l'attribut dans l'objet \texttt{context}. La boucle principale \texttt{run} se sert de \texttt{context}
pour afficher ce qu'il y a à afficher.

La boucle de menu posséde un type similaire, mais étant moins complexe, nous n'allons pas l'aborder en détail. Les noms des attributs parlent d'eux même.

Pour les attributs qui ne sont pas évidents : 

\begin{itemize}
    \item \texttt{cursor\_selector} représente l'objet \textit{Curseur}, qui contient sa position entre autres.
    \item \texttt{action\_src}, lorsqu'une action est en train d'être sélectionnée (pour le joueur humain), représente les coordonnées de la source
de l'action
    \item \texttt{action\_dst}, de manière similaire, représente la destination de l'action
    \item \texttt{action\_layer} représente la couche sur laquelle on veut effectuer l'action
    \item \texttt{action\_type} nous dit quelle action effectuer
    \item \texttt{movement\_range\_selector} est l'ensemble des tuiles sur laquelles la prochaine action va avoir un effet. Par exemple,
    si on veut faire un mouvement, on verra le tracé de la trajectoire.
    \item \texttt{to\_be\_added} et \texttt{to\_be\_deleted} représente une liste d'unité à ajouter, resp. à effacer.
    J'en discuterai plus tard dans le rapport. 
\end{itemize}

\subsection{Plateau du jeu}
Le plateau du jeu est (malheureusement) représenté par une matrice mutable. Chaque cellule contient des \texttt{MTile.t}. Le plateau a plusieurs
couche, représenté par des \texttt{MLayer\_enum.t}. L'idée est que chaque élément se retrouvant dans une même couche ne peut être sur la même position.
Si ce n'est pas le cas, elles peuvent se retrouver à la même position.

Il y a les fonctions de type \textit{getters} et \textit{setters}. Il y en a une de chaque pour les items, les tuiles et pour les unités.

Il y a également quelques fonctions un peu plus spécifiques, comme récupérer une zone de la carte, ou l'ennemi le plus proche, entre autres.

\subsubsection{\texttt{MTIle.t}}

Les constantes

\section{Problèmes et autre remarques}
\subsection{Build circulaire}
Vous remarquerez qu'il y a beaucoup de fichier ayant le nom \texttt{x\_enum.ml}. C'est ma solution pour contourner le problèmes des
\textit{circular builds}. Par exemple, \textit{faction\_enum.ml} contient des constantes pour chaque factions dans le jeu.
Les factions contiennent des unités, et les unités ont besoin de savoir à quelle faction elles appartiennent. On voit clairement
le problème de build circulaire. 

On se rend compte qu'au final, les unités n'ont pas besoin de savoir tout sur la faction, mais seulement dans quel camp ils sont (représenté par un enum),
et éventuellement un identifiant unique si il y a plusieurs camps ayant la même faction. Ainsi, les factions importent ce type, et 
les unités importent également ce type. Les unités ont besoin de tout juste ce qu'il faut et les factions contiennent les 
informations nécessaires pour leur bon fonctionnement.

Pour le reste des \texttt{x\_enum.ml} qu'on rencontre, on peut en dire la même chose.

\subsection{De bien trop grandes ambitions...}
Au début du projet nous étions bien trop ambitieux. C'était du au fait que c'était le seul projet qu'on avait à ce moment là. Puis
d'autres projets se sont greffés à nos emplois du temps, puis les examens, puis les concours externes à passer. Nous sommes quand même
contents de ce que nous avons fait. J'ai fait attention à rendre le code assez générique, si on le souhaitait, on peut facilement rajouter des unités,
des actions etc.

\newpage
\subsubsection{Quelques dessins non utilisés pour le rendu}
    \begin{figure}[H]
        \centering
     \includegraphics[scale=0.5]{asset/image/tech.png}
    \caption{Des icônes pour l'arbre de technologie}
    \vspace{1cm}

     \includegraphics[scale=0.5]{asset/image/skill.png}
    \caption{Des icônes pour l'arbre de compétence. Quelques icônes ont été réutilisés pour les actions}
    \vspace{1cm}

     \includegraphics[scale=0.5]{asset/image/sniper_eu.png}
    \caption{Une autre unité qui attaque à distance}
    \end{figure}

\section{Annexe \& Source}
\begin{itemize}
    \item Le pseudocode de la grille par hexagone : \url{https://www.redblobgames.com/grids/hexagons/}
    \item La musique du jeu : \url{https://soundcloud.com/leagueoflegends/omega-squad-teemo}
\end{itemize}


\end{document}
